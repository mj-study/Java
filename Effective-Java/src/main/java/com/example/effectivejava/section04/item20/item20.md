<aside>
💡

추상 클래스 사용

- 단일 상속을 강제하며, 상속 계층 구조를 고정 시켜 코드의 유연성을 제한할 수 있음

인터페이스 사용

- 다중 구현 허용, 클래스의 책임을 더 명확하게 분리, 객체 지향 설계 유연성을 높여줌
</aside>

## 📌 인터페이스 장점

- 다중 구현 지원
    - 인터페이스는 여러 개를 동시에 구현 가능 → 코드의 유연성과 재사용성 🔼
      클래스는 단일 부모 클래스만 상속 가능
- 구현 강요
    - 인터페이스는 해당 인터페이스를 구현하는 모든 클래스가 인터페이스의 모든 메서드를 구현하도록 구현하도록 강제함
      → 이를 통해 클래스의 일관성과 명확성을 높일 수 있음
- 믹스인(`mixin`) 사용 가능
    - 인터페이스를 통해 클래스를 특정 타입으로 정의하면서 동시에 공통 기능을 제공할 수 있음
      ex) `Comparable`이나 `Serializable` 같은 인터페이스를 구현하여 클래스에 기능을 혼합할 수 있음
- 설계 유연성
    - 기존 클래스를 변경하지 않고도 새로운 기능을 추가할 수 있도록 설계 유연성 제공
- OCP 준수
    - 기존 클래스를 수정하지 않고도 새 기능을 추가할 수 있음
      → OCP를 더 잘 준수함

## 📌 추상 클래스 제한점

- 단일 상속만 가능
    - 추상 클래스는 오직 하나의 클래스만 상속할 수 있으므로 다중 상속을 지원하지 않음
    - 클래스 계층 구조를 제한, 특정 클래스에 기능을 추가하는 유연성을 떨어뜨림
- 타입을 정의하지 않음
    - 추상 클래스는 특정 구현의 일부이기 때문에 그 자체로 타입을 정의하지 않음
- 재사용성 제한
    - 추상 클래스는 일반적으로 클래스 계층 구조의 일부분으로 사용되기 때문에 여러 클래스에서 재사용하기 어려움

## 📌 인터페이스와 골격 구현 클래스 조합

> 인터페이스 역할
>
- 인터페이스는 클래스가 구현해야 하는 메서드를 정의

> 골격 구현 클래스 역할
>
- 인터페이스의 기본적인 구현을 제공,
  인터페이스의 구현을 돕는 역할을 하며, 인터페이스의 일부 메서드를 이미 구현해 둠
- 이를 통해 인터페이스를 구현하는 개발자는 필요한 메서드만 재정의하면 되므로 인터페이스 구현이 훨씬 간단해짐
- 골격 구현 클래스는 일반적으로 추상 클래스로 제공, 인터페이스와의 결합을 통해 코드 중복을 줄이고 재사용성을 높임

## 📌 `List` 와 `AbstratList` 예시

> `List` 인터페이스
>
- 순서가 있는 요소의 집합을 정의, 요소 추가, 삭제, 검색 등의 메서드를 제공
- 구체적인 구현은 제공x

> `AbstractList` 골격 구현 클래스
>
- `List` 인터페이스의 많은 메서드에 대한 기본 구현을 제공, 부분적으로만 구현해도 됨
- 일부 메서드를 `abstract`로 선언하여 하위 클래스에서 반드시 구현하도록 강제하면서, 여러 메서드는 기본적으로 구현하여 하위 클래스가 모든 메서드를 구현할 필요가 없도록 함