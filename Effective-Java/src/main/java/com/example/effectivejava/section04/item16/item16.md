### public 필드를 사용할때 문제점

- 불변성 보장 어려움 : `public` 필드는 외부에서 직접 접근하고 수정이 가능함
  → 클래스 불변성 보장하기 어려움
  → 데이터 무결성을 해칠 수 있음
- 캡슐화 위반 : OOP에서 중요한 원칙 중 하나인 캡슐화
  → public 필드를 사용하면 클래스 내부의 구현이 외부로 노출되기 때문에, 내부 구현을 변경할때 외부 코드도 영향 받을 수 있음
- 유지보수 어려움 : public 필드 사용시 클래스 내부 표현 방식이 고정됨
  → 나중에 필드 타입이나 사용 방식을 변경하려 할 때, 외부에서 해당 필드를 사용하는 부분을 수정해야 할 수 있음
- 읽기 전용 필드 구현 어려움 : public 필드는 읽기 전용으로 만들기가 어려움
  → 반면, 접근자 메서드를 사용하면 `getter` 만 제공함으로 읽기 전용 속성을 쉽게 구현 가능

### 접근자 메서드 사용 이점

- `getter` `setter` 사용하는 것이 좋은 이유
1. 캡슐화 유지 : 클래스 내부 구현이 외부에 노출되지 않음
   → 필요에 따라 내부 구현을 변경하더라도 외부 API는 그대로 유지 가능
2. 필드에 대한 유효성 검사 : `setter` 메서드를 사용하여 필드에 값을 설정할 때 유효성 검사 추가 가능
3. 불변성 관리 용이 : `getter` 만 제공하고 `setter` 를 제공하지 않으면 해당 필드를 읽기 전용으로 만들 수 있음
4. API 확장성 : 접근자 메서드를 통해, 향후 요구 사항에 맞춰 기능을 추가하거나 변경할 수 있음

> `public` 필드를 사용한 클래스 (잘못된 코드 예)
>

```java
public class Point {
	public int x;
	public int y;
}
// 외부에서 접근하여 데이터 변경 가능
```

> 접근자 메서드를 사용한 클래스 (올바른 예)
>

```java
public class Point {
    private int x;
    private int y;

    // 생성자
    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    // 접근자 메서드 (getter)
    public int getX() {
        return x;
    }

    public int getY() {
        return y;
    }

    // 설정자 메서드 (setter)
    public void setX(int x) {
        this.x = x;
    }

    public void setY(int y) {
        this.y = y;
    }
}
```

## 📌 `public` 필드가 불변인 경우

### 불변 필드 장점

1. 간결한 코드
    - 클래스가 단순한 데이터 구조인 경우 `public` 필드 사용시 코드가 간결해짐
      → 별도의 `getter` 메서드 작성 x
    - 예시로, 수학적 구조체(2D 좌표, 복소수 등) 같이 불변성을 유지하는 간단한 클래스를 작성할 때 `public` 필드 사용하면 직관적임
2. 성능
    - `public` 필드 사용시 메서드 호출이 필요 없으므로 미세한 성능 향상 기대
      → 실제로는 성능 차이가 대부분의 경우 무시할 수 있을정도로 작음
3. 불변성 보장
    - 필드가 `final`로 선언되어 불변성 보장 가능, 무결성 유지

### 불변 필드 단점

1. 캡슐화 위반
    - 클래스 내부 구현이 외부로 드러남
      → 내부 구현 변경 어려워짐
2. API 확장 어려움
    - 클래스 내부 표현 방식을 변경할 수 없음, 나중에 요구사항이 변경되어 클래스의 기능을 확장해야 할 때, API를 수정하기 어려워짐
3. 객체의 불변성을 완전히 보장할 수 없음
    - 필드 자체가 불변이라해도, 필드의 타입이 객체일 경우 그 객체 내부의 상태는 변경될 수 있음

### `public` 불변 필드 사용하는 경우?

- 사용 ⭕
    - 클래스가 매우 단순한 데이터 구조, 불변성만 보장되면 충분한 경우
    - 성능이 극도로 중요한 경우
- 사용 ❌
    - 클래스 내부 구현이 변경될 가능성 있는 경우
    - 클래스가 복잡하거나 캡슐화가 중요한 경우
    - 필드가 참조형 타입인 경우(List, Map, Set 등)